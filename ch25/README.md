# 25.클래스
## 25.1 클래스
- 클래스는 기존 프로토타입 기반 객체지향 프로그래밍보다 자바나 C#과 같은 클래스 기반 객체지향 프로그래밍에 익숙한 프로그래머의 더욱 빠른 학습을 위한 새로운 객체 생성 매커니즘 이다.
### 클래스와 생성자 함수의 차이점
- 클래스를 new 연산자 없이 호출하면 에러가 발생한다.
- 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다.
- 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.
- 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되고, 해체할 수 없다.
- 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다. 열거되지 않는다.

## 25.2 클래스 정의
- 클래스는 class 키워드를 사용하여 정의한다.
```js
//클래스 선언문
class Person{}
//익명 클래스 표현식
const Person = class{};
//기명 클래스 표현식
const Person = class MyClass{}
```
- 클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용할 수 있는 일급 객체라는 것을 의미한다.
- 무명의 리터럴로 생성할 수 있다. 런타임에 생성 가능.
- 변수나 자료구조에 저장할 수 있다.
- 함수의 매개변수에게 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.
- 클래스 몸체에는 0개 이상의 메서드만 정의할 수 있다.(constructor, 프로토타입 메서드, 정적 메서드 세가지가 있다.)

## 25.3 클래스 호이스팅
- 클래스는 함수로 평가된다.
- 런타임 이전에 먼저 평가되어 함수 객체를 생성한다.
- 그러나, 클래스는 클래스 정의 이전에 참조할 수 없다.
- 클래스는 let, const 키워드로 선언한 변수처럼 호이스팅 된다.
- 따라서 클래스 선언문 이전에 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.

## 25.4 인스턴스 생성
- 클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 평가한다.
- 기명 함수 표현식과 마찬가지로 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근 불가능하다.

## 25.5 메서드
- 클래스 몸체에는 0개 이상의 메서드만 선언할 수 있다.
- 클래스 몸체에서 정의할 수 있는 메서드는 constructor(생성자), 프로토타입 메서드, 정적 메서드 3가지가 있다.

### 25.5.1 constructor
- constructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드다. 이름을 변경할 수 없다.
- constructor 내부의 this는 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스를 가리킨다.
- 클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티는 이름이 같아 혼동하기 쉽지만 직접적인 관련이 없다.
- constructor는 클래스 내에 최대 한 개만 존재할 수 있다.
- 생략할 수 있다. 생략할 경우 빈 constructor가 암묵적으로 정의된다.
- constructor는 별도의 반환문을 갖지 않는다.(암묵적으로 this 반환)
- 명시적으로 객체를 반환하면 암묵적인 this반환이 무시된다.
- 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.

### 25.5.2 프로토타입 메서드
- 클래스 몸체에서 정의한 메서드는 생성자 함수에 의한 객체 생성 방식과는 다르게 클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.

### 25.5.3 정적 메서드
- 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있는 메서드를 말한다.
- 클래스에서는 메서드에 static 키워드를 붙이면 정적 메서드(클래스 메서드)가 된다.
- 정적 메서드는 인스턴스로 호출할 수 없다.

### 25.5.4 정적 메서드와 프로토타입 메서드의 차이
- 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다.
- 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.
- 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.
- 메서드 내부에서 인스턴스 프로퍼티를 참조할 필요가 있다면 this를 사용해야 하며, 프로토타입 메서드로 정의해야 한다.
- this를 사용하지 않는 메서드는 정적 메서드로 정의하는 것이 좋다.

### 25.5.5 클래스에 정의한 메서드의 특징
- function 키워드를 생략한 메서드 축약 표현을 사용한다.
- 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다.
- 암묵적으로 strict mode로 실행된다.
- for...in문이나 Object.keys 메서드 등으로 열거할 수 없다.
- 내부 메서드 [[Constructor]]를 갖지 않는 non-constructor다. 따라서 new 연산자와 함께 호출할 수 없다.


## 25.6 클래스의 인스턴스 생성 과정
- 1.인스턴스 생성과 this 바인딩
- 2.인스턴스 초기화
- 3.인스턴스 반환

## 25.7 프로퍼티
### 25.7.1 인스턴스 프로퍼티
- 인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다.
- 인스턴스 프로퍼티는 언제나 public 하다.
- private한 프로퍼티를 정의할 수 있는 사양이 현재 제안 중에 있다.

### 25.7.2 접근자 프로퍼티
- 접근자 프로퍼티는 자체적으로는 값을 갖지 않고 달ㄴ 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다.

### 25.7.3 클래스 필드 정의 제안
- 클래스 필드는 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어다.
- 자바스크립트의 클래스 몸체에는 메서드만 선언할 수 있다.
- 그러나 자바스크립트에서도 인스턴스 프로퍼티를 마치 클래스 기반 객체지향 언어의 클래스 필드처럼 정의할 수 있는 새로운 표준 사양이 제안되었다.
- this는 클래스의 constructor와 메서드 내에서만 유효하다.
- 인스턴스를 생성할 때 클래스 필드를 초기화할 필요가 있다면 constructor 밖에서 클래스 필드를 정의할 필요가 없다.
- 클래스 필드를 초기화할 필요가 있다면 어차피 constructor 내부에서 클래스 필드를 참조하여 초기값을 할당해야 한다.
- 이 때 this, 즉 클래스가 생성한 인스턴스에 클래스 필드에 해당하는 프로퍼티가 없다면 자동 추가되기 때문이다.

### 25.7.4 private 필드 정의 제안
- private 필드를 정의할 수 있는 새로운 표준 사양이 제안 되어 있다.
- private 필드의 선두에는 #을 붙여준다. private 필드를 참조할 때도 #을 붙여주어야 한다.
- private 필드는 반드시 클래스 몸체에 정의해야 한다. 
- private 필드는 클래스 내부에서만 참조할 수 있다.
- 접근자 프로퍼티를 통해 간접적으로 접근할 수도 있긴 하다.

### 25.7.5 static 필드 정의 제안
- static public필드, static private필드, static private 메서드를 정의할 수 있는 새로운 표준 사양이 제안되어 있다.
